/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type PendingStruct = {
  timestamp: PromiseOrValue<BigNumberish>;
  native: PromiseOrValue<boolean>;
  amount: PromiseOrValue<BigNumberish>;
  exemption: PromiseOrValue<BigNumberish>;
};

export type PendingStructOutput = [number, boolean, BigNumber, BigNumber] & {
  timestamp: number;
  native: boolean;
  amount: BigNumber;
  exemption: BigNumber;
};

export type FundFlowStruct = {
  totalIn: PromiseOrValue<BigNumberish>;
  totalOut: PromiseOrValue<BigNumberish>;
};

export type FundFlowStructOutput = [BigNumber, BigNumber] & {
  totalIn: BigNumber;
  totalOut: BigNumber;
};

export type RangeStruct = {
  liquidity: PromiseOrValue<BigNumberish>;
  entryFeeIndex: PromiseOrValue<BigNumberish>;
  balance: PromiseOrValue<BigNumberish>;
  sqrtEntryPX96: PromiseOrValue<BigNumberish>;
};

export type RangeStructOutput = [BigNumber, BigNumber, BigNumber, BigNumber] & {
  liquidity: BigNumber;
  entryFeeIndex: BigNumber;
  balance: BigNumber;
  sqrtEntryPX96: BigNumber;
};

export interface GateInterface extends utils.Interface {
  functions: {
    "allInstruments(uint256)": FunctionFragment;
    "allInstrumentsLength()": FunctionFragment;
    "claimYield(address,address)": FunctionFragment;
    "config()": FunctionFragment;
    "configureYieldMode(address,uint8)": FunctionFragment;
    "deposit(bytes32)": FunctionFragment;
    "fundFlowOf(address,address)": FunctionFragment;
    "gather(address,address,uint32,uint256)": FunctionFragment;
    "getAllInstruments()": FunctionFragment;
    "indexOf(address)": FunctionFragment;
    "instrumentInitData()": FunctionFragment;
    "isBlacklisted(address)": FunctionFragment;
    "launch(string,address,bytes,bytes32[2])": FunctionFragment;
    "pendingDuration()": FunctionFragment;
    "pendingOf(address,address)": FunctionFragment;
    "release(address,address)": FunctionFragment;
    "reserveOf(address,address)": FunctionFragment;
    "scatter(address,address,uint32,uint256)": FunctionFragment;
    "setBlacklist(address,bool)": FunctionFragment;
    "setPendingDuration(uint256)": FunctionFragment;
    "setThreshold(address,uint256)": FunctionFragment;
    "syncPointsOperator()": FunctionFragment;
    "thresholdOf(address)": FunctionFragment;
    "weth()": FunctionFragment;
    "withdraw(bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "allInstruments"
      | "allInstrumentsLength"
      | "claimYield"
      | "config"
      | "configureYieldMode"
      | "deposit"
      | "fundFlowOf"
      | "gather"
      | "getAllInstruments"
      | "indexOf"
      | "instrumentInitData"
      | "isBlacklisted"
      | "launch"
      | "pendingDuration"
      | "pendingOf"
      | "release"
      | "reserveOf"
      | "scatter"
      | "setBlacklist"
      | "setPendingDuration"
      | "setThreshold"
      | "syncPointsOperator"
      | "thresholdOf"
      | "weth"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "allInstruments",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "allInstrumentsLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimYield",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "config", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "configureYieldMode",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "fundFlowOf",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "gather",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllInstruments",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "indexOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "instrumentInitData",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isBlacklisted",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "launch",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "pendingDuration",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pendingOf",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "release",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "reserveOf",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "scatter",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setBlacklist",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPendingDuration",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setThreshold",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "syncPointsOperator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "thresholdOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "weth", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(
    functionFragment: "allInstruments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allInstrumentsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claimYield", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "config", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "configureYieldMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fundFlowOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "gather", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAllInstruments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "indexOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "instrumentInitData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlacklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "launch", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pendingOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "release", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "reserveOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "scatter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBlacklist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPendingDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "syncPointsOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "thresholdOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "weth", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "Blacklist(address,bool)": EventFragment;
    "Deposit(address,address,uint256)": EventFragment;
    "Gather(address,address,address,uint32,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "NewInstrument(bytes32,address,address,address,string,uint256)": EventFragment;
    "Scatter(address,address,address,uint32,uint256)": EventFragment;
    "SetPendingDuration(uint256)": EventFragment;
    "SetThreshold(address,uint256)": EventFragment;
    "UpdatePending(address,address,tuple)": EventFragment;
    "Withdraw(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Blacklist"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Gather"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewInstrument"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Scatter"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPendingDuration"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetThreshold"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatePending"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
}

export interface BlacklistEventObject {
  trader: string;
  banned: boolean;
}
export type BlacklistEvent = TypedEvent<
  [string, boolean],
  BlacklistEventObject
>;

export type BlacklistEventFilter = TypedEventFilter<BlacklistEvent>;

export interface DepositEventObject {
  quote: string;
  trader: string;
  quantity: BigNumber;
}
export type DepositEvent = TypedEvent<
  [string, string, BigNumber],
  DepositEventObject
>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface GatherEventObject {
  quote: string;
  trader: string;
  instrument: string;
  expiry: number;
  quantity: BigNumber;
}
export type GatherEvent = TypedEvent<
  [string, string, string, number, BigNumber],
  GatherEventObject
>;

export type GatherEventFilter = TypedEventFilter<GatherEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface NewInstrumentEventObject {
  index: string;
  instrument: string;
  base: string;
  quote: string;
  symbol: string;
  total: BigNumber;
}
export type NewInstrumentEvent = TypedEvent<
  [string, string, string, string, string, BigNumber],
  NewInstrumentEventObject
>;

export type NewInstrumentEventFilter = TypedEventFilter<NewInstrumentEvent>;

export interface ScatterEventObject {
  quote: string;
  trader: string;
  instrument: string;
  expiry: number;
  quantity: BigNumber;
}
export type ScatterEvent = TypedEvent<
  [string, string, string, number, BigNumber],
  ScatterEventObject
>;

export type ScatterEventFilter = TypedEventFilter<ScatterEvent>;

export interface SetPendingDurationEventObject {
  duration: BigNumber;
}
export type SetPendingDurationEvent = TypedEvent<
  [BigNumber],
  SetPendingDurationEventObject
>;

export type SetPendingDurationEventFilter =
  TypedEventFilter<SetPendingDurationEvent>;

export interface SetThresholdEventObject {
  quote: string;
  threshold: BigNumber;
}
export type SetThresholdEvent = TypedEvent<
  [string, BigNumber],
  SetThresholdEventObject
>;

export type SetThresholdEventFilter = TypedEventFilter<SetThresholdEvent>;

export interface UpdatePendingEventObject {
  quote: string;
  trader: string;
  pending: PendingStructOutput;
}
export type UpdatePendingEvent = TypedEvent<
  [string, string, PendingStructOutput],
  UpdatePendingEventObject
>;

export type UpdatePendingEventFilter = TypedEventFilter<UpdatePendingEvent>;

export interface WithdrawEventObject {
  quote: string;
  trader: string;
  quantity: BigNumber;
}
export type WithdrawEvent = TypedEvent<
  [string, string, BigNumber],
  WithdrawEventObject
>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface Gate extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GateInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    allInstruments(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    allInstrumentsLength(overrides?: CallOverrides): Promise<[BigNumber]>;

    claimYield(
      quote: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    config(overrides?: CallOverrides): Promise<[string]>;

    configureYieldMode(
      quote: PromiseOrValue<string>,
      yieldMode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deposit(
      arg: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fundFlowOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FundFlowStructOutput] & { fundFlow: FundFlowStructOutput }>;

    gather(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAllInstruments(overrides?: CallOverrides): Promise<[string[]]>;

    indexOf(
      instrument: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string] & { index: string }>;

    instrumentInitData(overrides?: CallOverrides): Promise<[string]>;

    isBlacklisted(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    launch(
      mtype: PromiseOrValue<string>,
      instrument: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      addArgs: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pendingDuration(overrides?: CallOverrides): Promise<[BigNumber]>;

    pendingOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[PendingStructOutput] & { pending: PendingStructOutput }>;

    release(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    reserveOf(
      quote: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { balance: BigNumber }>;

    scatter(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBlacklist(
      trader: PromiseOrValue<string>,
      banned: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPendingDuration(
      duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setThreshold(
      quote: PromiseOrValue<string>,
      threshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    syncPointsOperator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    thresholdOf(
      quote: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { threshold: BigNumber }>;

    weth(overrides?: CallOverrides): Promise<[string]>;

    withdraw(
      arg: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  allInstruments(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  allInstrumentsLength(overrides?: CallOverrides): Promise<BigNumber>;

  claimYield(
    quote: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  config(overrides?: CallOverrides): Promise<string>;

  configureYieldMode(
    quote: PromiseOrValue<string>,
    yieldMode: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deposit(
    arg: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fundFlowOf(
    quote: PromiseOrValue<string>,
    trader: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FundFlowStructOutput>;

  gather(
    quote: PromiseOrValue<string>,
    trader: PromiseOrValue<string>,
    expiry: PromiseOrValue<BigNumberish>,
    quantity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAllInstruments(overrides?: CallOverrides): Promise<string[]>;

  indexOf(
    instrument: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  instrumentInitData(overrides?: CallOverrides): Promise<string>;

  isBlacklisted(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  launch(
    mtype: PromiseOrValue<string>,
    instrument: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    addArgs: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pendingDuration(overrides?: CallOverrides): Promise<BigNumber>;

  pendingOf(
    quote: PromiseOrValue<string>,
    trader: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<PendingStructOutput>;

  release(
    quote: PromiseOrValue<string>,
    trader: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  reserveOf(
    quote: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  scatter(
    quote: PromiseOrValue<string>,
    trader: PromiseOrValue<string>,
    expiry: PromiseOrValue<BigNumberish>,
    quantity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBlacklist(
    trader: PromiseOrValue<string>,
    banned: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPendingDuration(
    duration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setThreshold(
    quote: PromiseOrValue<string>,
    threshold: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  syncPointsOperator(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  thresholdOf(
    quote: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  weth(overrides?: CallOverrides): Promise<string>;

  withdraw(
    arg: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    allInstruments(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    allInstrumentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    claimYield(
      quote: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    config(overrides?: CallOverrides): Promise<string>;

    configureYieldMode(
      quote: PromiseOrValue<string>,
      yieldMode: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    deposit(
      arg: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    fundFlowOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FundFlowStructOutput>;

    gather(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAllInstruments(overrides?: CallOverrides): Promise<string[]>;

    indexOf(
      instrument: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    instrumentInitData(overrides?: CallOverrides): Promise<string>;

    isBlacklisted(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    launch(
      mtype: PromiseOrValue<string>,
      instrument: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      addArgs: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
      overrides?: CallOverrides
    ): Promise<
      [number, number, RangeStructOutput] & {
        tickLower: number;
        tickUpper: number;
        range: RangeStructOutput;
      }
    >;

    pendingDuration(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PendingStructOutput>;

    release(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    reserveOf(
      quote: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scatter(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBlacklist(
      trader: PromiseOrValue<string>,
      banned: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPendingDuration(
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setThreshold(
      quote: PromiseOrValue<string>,
      threshold: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    syncPointsOperator(overrides?: CallOverrides): Promise<void>;

    thresholdOf(
      quote: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    weth(overrides?: CallOverrides): Promise<string>;

    withdraw(
      arg: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "Blacklist(address,bool)"(
      trader?: PromiseOrValue<string> | null,
      banned?: null
    ): BlacklistEventFilter;
    Blacklist(
      trader?: PromiseOrValue<string> | null,
      banned?: null
    ): BlacklistEventFilter;

    "Deposit(address,address,uint256)"(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      quantity?: null
    ): DepositEventFilter;
    Deposit(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      quantity?: null
    ): DepositEventFilter;

    "Gather(address,address,address,uint32,uint256)"(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      instrument?: PromiseOrValue<string> | null,
      expiry?: null,
      quantity?: null
    ): GatherEventFilter;
    Gather(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      instrument?: PromiseOrValue<string> | null,
      expiry?: null,
      quantity?: null
    ): GatherEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "NewInstrument(bytes32,address,address,address,string,uint256)"(
      index?: null,
      instrument?: null,
      base?: null,
      quote?: null,
      symbol?: null,
      total?: null
    ): NewInstrumentEventFilter;
    NewInstrument(
      index?: null,
      instrument?: null,
      base?: null,
      quote?: null,
      symbol?: null,
      total?: null
    ): NewInstrumentEventFilter;

    "Scatter(address,address,address,uint32,uint256)"(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      instrument?: PromiseOrValue<string> | null,
      expiry?: null,
      quantity?: null
    ): ScatterEventFilter;
    Scatter(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      instrument?: PromiseOrValue<string> | null,
      expiry?: null,
      quantity?: null
    ): ScatterEventFilter;

    "SetPendingDuration(uint256)"(
      duration?: null
    ): SetPendingDurationEventFilter;
    SetPendingDuration(duration?: null): SetPendingDurationEventFilter;

    "SetThreshold(address,uint256)"(
      quote?: PromiseOrValue<string> | null,
      threshold?: null
    ): SetThresholdEventFilter;
    SetThreshold(
      quote?: PromiseOrValue<string> | null,
      threshold?: null
    ): SetThresholdEventFilter;

    "UpdatePending(address,address,tuple)"(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      pending?: null
    ): UpdatePendingEventFilter;
    UpdatePending(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      pending?: null
    ): UpdatePendingEventFilter;

    "Withdraw(address,address,uint256)"(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      quantity?: null
    ): WithdrawEventFilter;
    Withdraw(
      quote?: PromiseOrValue<string> | null,
      trader?: PromiseOrValue<string> | null,
      quantity?: null
    ): WithdrawEventFilter;
  };

  estimateGas: {
    allInstruments(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    allInstrumentsLength(overrides?: CallOverrides): Promise<BigNumber>;

    claimYield(
      quote: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    config(overrides?: CallOverrides): Promise<BigNumber>;

    configureYieldMode(
      quote: PromiseOrValue<string>,
      yieldMode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deposit(
      arg: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fundFlowOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gather(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAllInstruments(overrides?: CallOverrides): Promise<BigNumber>;

    indexOf(
      instrument: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    instrumentInitData(overrides?: CallOverrides): Promise<BigNumber>;

    isBlacklisted(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    launch(
      mtype: PromiseOrValue<string>,
      instrument: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      addArgs: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pendingDuration(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    release(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    reserveOf(
      quote: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scatter(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBlacklist(
      trader: PromiseOrValue<string>,
      banned: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPendingDuration(
      duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setThreshold(
      quote: PromiseOrValue<string>,
      threshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    syncPointsOperator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    thresholdOf(
      quote: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    weth(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      arg: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allInstruments(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    allInstrumentsLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimYield(
      quote: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    config(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    configureYieldMode(
      quote: PromiseOrValue<string>,
      yieldMode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deposit(
      arg: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fundFlowOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    gather(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAllInstruments(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    indexOf(
      instrument: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    instrumentInitData(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlacklisted(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    launch(
      mtype: PromiseOrValue<string>,
      instrument: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      addArgs: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pendingDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOf(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    release(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    reserveOf(
      quote: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    scatter(
      quote: PromiseOrValue<string>,
      trader: PromiseOrValue<string>,
      expiry: PromiseOrValue<BigNumberish>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBlacklist(
      trader: PromiseOrValue<string>,
      banned: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPendingDuration(
      duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setThreshold(
      quote: PromiseOrValue<string>,
      threshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    syncPointsOperator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    thresholdOf(
      quote: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    weth(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      arg: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
